#' Sequential outlier rejection
#'
#' Iteratively fit a model to data and remove the most extreme residual. Three models are implemented here: ordinary least squares (lm), generalized linear model (glm), generalized additive model (GAM).
#'
#' @param data Data frame containing predictor and response variables.
#' @param method Character vector of length one indicating which function should be used to fit models. Options are 'lm', 'glm', or 'gam'.
#' @param fn Formula to be passed to the model. Formula must be valid for the selected method.
#' @param plot Logical vector indicating whether the function should print plots.
#' @param n.reject Numerical vector of length one. Number of observations to be rejected in each iteration. Larger values speed the funciton up, but may impede precise detection of break points.
#' @param n.stop Numerical vector of length one which indicating the number of observations remaining or proportion of initial observations which should be remaining before outlier rejection stops. For example, with 400 initial observations, n.stop set to 40 or 0.1 (= 400*0.1) would stop the algorithm when 40 observations remain.
#' @param ... Additional arguments passed to function calls (family, offset, etc.)
#'
#' @return The function returns a list with (1) input data frame with an additional column indicating the order in which observations were rejected, (2) a data frame


sequentialOR <- function(data, y = NULL, method = 'lm', formula, n.reject = 1, plot = T, n.stop, tail = "both", ...) {

  data$SOR_RANK <- NA
  rownames(data) <- 1:nrow(data)

  if(n.stop < 1) {
    n.stop <- n.stop * nrow(data)
  }

  iter <- floor((nrow(data) - n.stop) / n.reject)
  RMSE <- rep(NA, iter)
  NN <- rep(NA, iter)

  # Rejection counter
  rejection <- 1

  for(i in 1:iter) {

    # data.sub <- data[which(is.na(data$SOR_RANK)),]

    data.sub <- subset(data, is.na(SOR_RANK))

    if(method == 'lm') {
      mod <- lm(formula, data = data.sub, ...)
    }

    if(method == 'glm') {
      mod <- glm(formula, data = data.sub, ...)
    }

    if(method == 'gam') {
      mod <- gam(formula, data = data.sub, ...)
    }

    data.sub$resid <- resid(mod)

    if(tail == "both") {
      #data$SOR_RANK[as.numeric(names(resid(mod)[rev(order(abs(resid(mod))))]))[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))

      data$SOR_RANK[as.numeric(rownames(data.sub)[rev(order(abs(data.sub$resid)))])[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))
    }

    if(tail == "upper") {
      #data$SOR_RANK[as.numeric(names(resid(mod)[rev(order(resid(mod)))]))[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))

      data$SOR_RANK[as.numeric(rownames(data.sub)[rev(order(data.sub$resid))])[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))

    }

    if(tail == "lower") {
      #data$SOR_RANK[as.numeric(names(resid(mod)[order(resid(mod))]))[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))

      data$SOR_RANK[as.numeric(rownames(data.sub)[order(data.sub$resid)])[rejection:(rejection+n.reject-1)]] <- c(rejection:(rejection+n.reject-1))
    }



    RMSE[i] <- mean(residuals(mod)^2)
    NN[i] <- nrow(data.sub)
    rejection <- rejection + n.reject
  }

  out1 <- data.frame(N = NN, RMSE = RMSE)

  if(plot == T) {
    print(plot(NN, RMSE, xlim = c(nrow(data) + n.reject, n.stop - n.reject)))
  }

  output <- list(obs_rank = data,
                 rmse = out1)
  return(output)

}
