test <- bbb$datetime[1]
bbb$datetime[1]
force_tz(test, "America/Los_Angeles")
test <- bbb$datetime[1]
force_tz(test, "America/Los_Angeles")
library(TLUtilities)
getwd()
setwd("../testing_space/")
View(time_adjustments.R)
View(time_adjustments)
require(TLUtilities)
View(time_adjustments)
library(TLUtilities)
View(time_adjustments)
View(surface_light)
### Messing with timestamps
test <- bbb$datetime[1]
test
test2 <- force_tz(test, "America/Los_Angeles")
require(lubridate)
test2 <- force_tz(test, "America/Los_Angeles")
test2
test
with_tz(test2, "America/Anchorage")
library(TLUtilities)
dir("C:/Users/seanr/OneDrive/afsc/Light data processing/testing_space/data/LightData/Data/year_06/ebs/"
)
dir("C:/Users/seanr/OneDrive/afsc/Light data processing/testing_space/data/LightData/Data/year_06/ebs/v_88")
getwd()
library(TLUtilities)
test <- data.frame(x = c(1,2,3), y = c("a", "b", "c"))
id.col = c("x", "y")
parse(id.col)
paste0("test$", id.col)
eval(paste0("test$", id.col))
eval(text = paste0("test$", id.col))
parse(text = paste0("test$", id.col))
eval(parse(text = paste0("test$", id.col)))
eval(paste(parse(text = paste0("test$", id.col))))
eval(paste(paste0("test$", id.col)))
eval(paste(paste0("test$", id.col), sep = ","))
eval(paste(paste("test$", id.col), sep = ","))
eval(paste(paste0("test$", id.col), sep = ","))
paste0("test$", id.col)
eval(paste("test$", id.col), sep = ",")
eval(paste("test$", id.col, sep = ",")
)
id.col <- paste0("test$", id.col)
id.col
length(id.col)
eval(id.col[2])
eval(parse(text = id.col[2]))
paste(id.col, collapse = T)
?paste
paste(id.col, collapse = ",")
id.col <- c("x", "y")
id.col <- paste(paste0("test$", id.col), collapse = ",")
id.col
paste(paste0("test$", id.col), collapse = ",")
id.col <- c("x", "y")
id.col <- paste(paste0("test$", id.col), collapse = ",")
id.col
id.col <- c("x", "y")
id.col <- paste0("paste(", paste(paste0("test$", id.col), collapse = ","),")")
id.col
id.col <- c("x", "y")
id.col <- eval(parse(text = paste0("paste(", paste(paste0("test$", id.col), collapse = ","),")"))
id.col
?paste
id.col[2]))
id.col <- eval(parse(text = paste0("paste(", paste(paste0("test$", id.col), collapse = ","),")")))
id.col
View(integrate)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(trawllight)
install.packages(c("fishmethods", "lubridate"))
library(TLUtilities)
rm(list = ls())
library(trawllight)
library(ggplot2)
library(plyr)
library(dplyr)
library(fishmethods)
library(TLUtilities)
# source TLUtilities functions for testing
sapply(paste("./R/", dir("./R/"), sep = ""), source)
# Import csv file containing filepaths for light data DIRECTORIES. Each target directories should contain corr_Mk9Hauls.csv, deck1**.csv, and CastTimes.csv for a vessel/cruise combination. This list needs to be created by the user.
light.dir <- read.csv("../testing_space/imports/directories.csv", header = F, stringsAsFactors = F)
# Only use EBS shelf directories.
light.dir <- light.dir[which(grepl("ebs", light.dir[,1])),1]
light.dir
# Only use EBS shelf directories.
light.dir <- light.dir[which(grepl("ebs", light.dir[,1])),1]
# Let's examine what this does
print(head(light.dir))
# source TLUtilities functions for testing
sapply(paste("./R/", dir("./R/"), sep = ""), source)
# Import csv file containing filepaths for light data DIRECTORIES. Each target directories should contain corr_Mk9Hauls.csv, deck1**.csv, and CastTimes.csv for a vessel/cruise combination. This list needs to be created by the user.
light.dir <- read.csv("../testing_space/imports/directories.csv", header = F, stringsAsFactors = F)
# Only use EBS shelf directories.
light.dir <- light.dir[which(grepl("ebs", light.dir[,1])),1]
# Let's examine what this does
print(head(light.dir))
# Wrapper function which runs TLUtilies::vertical_profiles(), trawllight::filter_stepwise(), and trawllight::calculate_attenuation() for every cast in each of the target directories. It is advisable to process only a few dierectories at a time due R memory limits and the potential for processing errors to occur. "Downcast" and "Upcast" should be processed separately. Here, I only use the 10th directory for Vessel 89, Cruise 200801
ebs <- process_all(dir.structure = light.dir[10:12],
cast.dir = "Downcast",
silent = T)
# ebs is a list containing four data frames: loess_eval, atten_values, light_ratios, resid_fit. Described below.
names(ebs)
library(trawllight)
### Demonstrating alternative algorithms to smooth raw light data
require(trawllight)
require(castr)
require(devtools)
install_github("jiho/castr")
install.packages("devtools")
require(devtools)
install_github("jiho/castr")
require(castr)
dir()
dir("./data/")
dir("./data")
dir("../../")
dir("../../../")
test <- test_process_all(dir.structure = "../../../Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_09/ebs/v_89",
cast.dir = "Downcast",
silent = T)
test <- subset(test, vessel == 89 & cruise == 200901)
direct.orient <- readRDS(file = "../../../Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/output/downcasts_algorithm.rds")
indirect.orient <- readRDS(file = "../../../Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/output/downcasts_indirect_algorithm.rds")
loess.resid <- readRDS(file = "../../../Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/output/loess_residuals.rds")
haulz <- unique(test$haul)
stepwise <- vector()
mod_fit <- vector()
head(test)
i = 1
i = 10
testA <- subset(test, haul == haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_continuous(name = "log10(light)") +
ggtitle(haulz[i])
test2 <- testA
test2$dbin <- findInterval(test2$cdepth, seq(0, max(test2$cdepth), 2), rightmost.closed = T, left.open = F) * 2 - 2/2
test3 <- aggregate(trans_llight ~ vessel + cruise + haul + dbin, data = test2, FUN = median)
ggplot() +
geom_point(data = testA, aes(y = cdepth, x = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
geom_point(data = test2, aes(y = dbin, x = log10(trans_llight)), color = "red") +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(haulz[i])
require(lubridate)
ggplot() +
geom_point(data = testA, aes(x = ctime, y = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_continuous(name = "log10(light)") +
ggtitle(haulz[i])
class(testA$ctime)
install.packages("hms")
require(hms)
ggplot() +
geom_point(data = testA, aes(x = ctime, y = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_continuous(name = "log10(light)") +
ggtitle(haulz[i])
i = 2
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "log10(light)") +
ggtitle(haulz[i])
i = 1
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "log10(light)") +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth), color = "black", size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light))) +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light)), limits = c(4,-7)) +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light))) +
ggtitle(haulz[i])
pdf(file = "D:/test_downcasts.pdf", width = 10, height = 8)
for(i in 1:length(haulz)) {
testA <- subset(test, haul == haulz[i])
test2 <- testA
test2$dbin <- findInterval(test2$cdepth, seq(0, max(test2$cdepth), 2), rightmost.closed = T, left.open = F) * 2 - 2/2
test3 <- aggregate(trans_llight ~ vessel + cruise + haul + dbin, data = test2, FUN = median)
if(nrow(test3) > 4) {
test3.las2 <- loess.as2(x = test3$dbin, y = log10(test3$trans_llight))
test4 <- filter_stepwise(test2, depth.col = "cdepth", light.col = "trans_llight", agg.fun = median)
test4.las2 <- loess.as2(x = test4$cdepth, y = log10(test4$trans_llight))
plot1 <- ggplot() +
geom_point(data = testA, aes(y = cdepth, x = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
geom_point(data = test2, aes(y = dbin, x = log10(trans_llight)), color = "red") +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(haulz[i])
plot5 <- ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light))) +
ggtitle(haulz[i])
plot2 <- ggplot() +
geom_point(data = test4, aes(y = cdepth, x = log10(trans_llight)), color = "blue", size = rel(3), alpha = 0.5) +
geom_point(data = test3, aes(y = dbin, x = log10(trans_llight)), color = "red") +
geom_path(aes(y = seq(min(test3$dbin), max(test3$dbin), 0.2), x = predict(test3.las2, newdata = seq(min(test3$dbin), max(test3$dbin), 0.2))), color = "red") +
geom_path(aes(y = seq(min(test4$cdepth), max(test4$cdepth), 0.2), x = predict(test4.las2, newdata = seq(min(test4$cdepth), max(test4$cdepth), 0.2))), color = "blue", linetype = 2) +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(" ")
direct.orient.sub <- subset(direct.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
indirect.orient.sub <- subset(indirect.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
if(nrow(direct.orient.sub) >= 1) {
direct.orient.sub <- subset(direct.orient.sub, cdepth == min(direct.orient.sub$cdepth))
plot3 <- ggplot() + geom_density(aes(x = direct.orient$direct_residual[direct.orient$cdepth == min(direct.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = direct.orient.sub$direct_residual[1]), color = "red", linetype = 2) +
ggtitle(paste0("Quality: ", direct.orient.sub$quality, ", Min. Depth: ", min(direct.orient.sub$cdepth))) +
scale_x_continuous(name = "Direct residual") +
scale_y_continuous(name = "Density")
} else {
plot3 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
if(nrow(indirect.orient.sub) >= 1) {
indirect.orient.sub <- subset(indirect.orient.sub, cdepth == min(indirect.orient.sub$cdepth))
plot4 <- ggplot() + geom_density(aes(x = indirect.orient$light_residual[indirect.orient$cdepth == min(indirect.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = indirect.orient.sub$light_residual[1]), color = "red", linetype = 2) +
scale_x_continuous(name = "Indirect residual") +
scale_y_continuous(name = "Density") + ggtitle(" ")
} else {
plot4 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
print(grid.arrange(plot1, plot5, plot2, plot3, plot4, nrow = 2))
stepwise <- c(stepwise, mean(resid(test4.las2)^2))
mod_fit <- c(mod_fit, mean(resid(test3.las2)^2))
}
}
dev.off()
require(gridExtra)
pdf(file = "D:/test_downcasts.pdf", width = 10, height = 8)
for(i in 1:length(haulz)) {
testA <- subset(test, haul == haulz[i])
test2 <- testA
test2$dbin <- findInterval(test2$cdepth, seq(0, max(test2$cdepth), 2), rightmost.closed = T, left.open = F) * 2 - 2/2
test3 <- aggregate(trans_llight ~ vessel + cruise + haul + dbin, data = test2, FUN = median)
if(nrow(test3) > 4) {
test3.las2 <- loess.as2(x = test3$dbin, y = log10(test3$trans_llight))
test4 <- filter_stepwise(test2, depth.col = "cdepth", light.col = "trans_llight", agg.fun = median)
test4.las2 <- loess.as2(x = test4$cdepth, y = log10(test4$trans_llight))
plot1 <- ggplot() +
geom_point(data = testA, aes(y = cdepth, x = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
geom_point(data = test2, aes(y = dbin, x = log10(trans_llight)), color = "red") +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(haulz[i])
plot5 <- ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light))) +
ggtitle(haulz[i])
plot2 <- ggplot() +
geom_point(data = test4, aes(y = cdepth, x = log10(trans_llight)), color = "blue", size = rel(3), alpha = 0.5) +
geom_point(data = test3, aes(y = dbin, x = log10(trans_llight)), color = "red") +
geom_path(aes(y = seq(min(test3$dbin), max(test3$dbin), 0.2), x = predict(test3.las2, newdata = seq(min(test3$dbin), max(test3$dbin), 0.2))), color = "red") +
geom_path(aes(y = seq(min(test4$cdepth), max(test4$cdepth), 0.2), x = predict(test4.las2, newdata = seq(min(test4$cdepth), max(test4$cdepth), 0.2))), color = "blue", linetype = 2) +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(" ")
direct.orient.sub <- subset(direct.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
indirect.orient.sub <- subset(indirect.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
if(nrow(direct.orient.sub) >= 1) {
direct.orient.sub <- subset(direct.orient.sub, cdepth == min(direct.orient.sub$cdepth))
plot3 <- ggplot() + geom_density(aes(x = direct.orient$direct_residual[direct.orient$cdepth == min(direct.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = direct.orient.sub$direct_residual[1]), color = "red", linetype = 2) +
ggtitle(paste0("Quality: ", direct.orient.sub$quality, ", Min. Depth: ", min(direct.orient.sub$cdepth))) +
scale_x_continuous(name = "Direct residual") +
scale_y_continuous(name = "Density")
} else {
plot3 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
if(nrow(indirect.orient.sub) >= 1) {
indirect.orient.sub <- subset(indirect.orient.sub, cdepth == min(indirect.orient.sub$cdepth))
plot4 <- ggplot() + geom_density(aes(x = indirect.orient$light_residual[indirect.orient$cdepth == min(indirect.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = indirect.orient.sub$light_residual[1]), color = "red", linetype = 2) +
scale_x_continuous(name = "Indirect residual") +
scale_y_continuous(name = "Density") + ggtitle(" ")
} else {
plot4 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
print(grid.arrange(plot1, plot5, plot2, plot3, plot4, nrow = 2))
stepwise <- c(stepwise, mean(resid(test4.las2)^2))
mod_fit <- c(mod_fit, mean(resid(test3.las2)^2))
}
}
dev.off()
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light)), breaks = seq(-7,3,1)) +
ggtitle(haulz[i])
ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light)), breaks = seq(-7,3,1), limits = c(-7,3)) +
ggtitle(haulz[i])
min(test$trans_llight)
max(test$trans_llight)
pdf(file = "D:/test_downcasts.pdf", width = 10, height = 8)
dir()
getwd()
dir("../..")
dir("../")
dir("../testing_space")
stepwise <- vector()
mod_fit <- vector()
pdf(file = "../testing_space/output/test_downcasts_time_depth.pdf", width = 10, height = 8)
for(i in 1:length(haulz)) {
testA <- subset(test, haul == haulz[i])
test2 <- testA
test2$dbin <- findInterval(test2$cdepth, seq(0, max(test2$cdepth), 2), rightmost.closed = T, left.open = F) * 2 - 2/2
test3 <- aggregate(trans_llight ~ vessel + cruise + haul + dbin, data = test2, FUN = median)
if(nrow(test3) > 4) {
test3.las2 <- loess.as2(x = test3$dbin, y = log10(test3$trans_llight))
test4 <- filter_stepwise(test2, depth.col = "cdepth", light.col = "trans_llight", agg.fun = median)
test4.las2 <- loess.as2(x = test4$cdepth, y = log10(test4$trans_llight))
plot5 <- ggplot() +
geom_point(data = testA, aes(x = ctime, y = cdepth, color = log10(trans_llight)), size = rel(3), alpha = 0.5) +
scale_x_time(name = "Time") +
scale_y_reverse(name = "Depth") +
scale_color_viridis_c(name = expression(log[10](Light)), breaks = seq(-6,3,1), limits = c(-6.5,3)) +
ggtitle(haulz[i])
plot1 <- ggplot() +
geom_point(data = testA, aes(y = cdepth, x = log10(trans_llight)), color = "black", size = rel(3), alpha = 0.5) +
geom_point(data = test2, aes(y = dbin, x = log10(trans_llight)), color = "red") +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(haulz[i])
plot2 <- ggplot() +
geom_point(data = test4, aes(y = cdepth, x = log10(trans_llight)), color = "blue", size = rel(3), alpha = 0.5) +
geom_point(data = test3, aes(y = dbin, x = log10(trans_llight)), color = "red") +
geom_path(aes(y = seq(min(test3$dbin), max(test3$dbin), 0.2), x = predict(test3.las2, newdata = seq(min(test3$dbin), max(test3$dbin), 0.2))), color = "red") +
geom_path(aes(y = seq(min(test4$cdepth), max(test4$cdepth), 0.2), x = predict(test4.las2, newdata = seq(min(test4$cdepth), max(test4$cdepth), 0.2))), color = "blue", linetype = 2) +
scale_y_reverse(name = "Depth") +
scale_x_continuous(name = "log10(light)") +
ggtitle(" ")
direct.orient.sub <- subset(direct.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
indirect.orient.sub <- subset(indirect.orient, haul == haulz[i] & (cruise == 200901 & vessel == 89))
if(nrow(direct.orient.sub) >= 1) {
direct.orient.sub <- subset(direct.orient.sub, cdepth == min(direct.orient.sub$cdepth))
plot3 <- ggplot() + geom_density(aes(x = direct.orient$direct_residual[direct.orient$cdepth == min(direct.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = direct.orient.sub$direct_residual[1]), color = "red", linetype = 2) +
ggtitle(paste0("Quality: ", direct.orient.sub$quality, ", Min. Depth: ", min(direct.orient.sub$cdepth))) +
scale_x_continuous(name = "Direct residual") +
scale_y_continuous(name = "Density")
} else {
plot3 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
if(nrow(indirect.orient.sub) >= 1) {
indirect.orient.sub <- subset(indirect.orient.sub, cdepth == min(indirect.orient.sub$cdepth))
plot4 <- ggplot() + geom_density(aes(x = indirect.orient$light_residual[indirect.orient$cdepth == min(indirect.orient.sub$cdepth)])) +
geom_vline(aes(xintercept = indirect.orient.sub$light_residual[1]), color = "red", linetype = 2) +
scale_x_continuous(name = "Indirect residual") +
scale_y_continuous(name = "Density") + ggtitle(" ")
} else {
plot4 <- ggplot() + geom_text(aes(x = 1, y = 1, label = "Minimum depth > 5 m")) + ggtitle(" ")
}
print(grid.arrange(plot1, plot5, plot2, plot3, plot4, nrow = 2))
stepwise <- c(stepwise, mean(resid(test4.las2)^2))
mod_fit <- c(mod_fit, mean(resid(test3.las2)^2))
}
}
dev.off()
install.packages(c("oce", "fields"))
install.packages("fishmethods")
install.packages(c("oce", "fields"))
install.packages("fishmethods")
require(trawllight)
require(TLUtilities)
rm(list = ls())
library(trawllight)
library(ggplot2)
library(plyr)
library(dplyr)
library(fishmethods)
library(TLUtilities)
# source TLUtilities functions for testing
sapply(paste("./R/", dir("./R/"), sep = ""), source)
# Import csv file containing filepaths for light data DIRECTORIES. Each target directories should contain corr_Mk9Hauls.csv, deck1**.csv, and CastTimes.csv for a vessel/cruise combination. This list needs to be created by the user.
light.dir <- read.csv("../testing_space/imports/directories.csv", header = F, stringsAsFactors = F)
# Only use EBS shelf directories.
light.dir <- light.dir[which(grepl("ebs", light.dir[,1])),1]
# Let's examine what this does
print(head(light.dir))
# Import csv file containing filepaths for light data DIRECTORIES. Each target directories should contain corr_Mk9Hauls.csv, deck1**.csv, and CastTimes.csv for a vessel/cruise combination. This list needs to be created by the user.
light.dir <- read.csv("../testing_space/imports/directories.csv", header = F, stringsAsFactors = F)
light.dir
# Only use EBS shelf directories.
light.dir <- light.dir[which(grepl("ebs", light.dir[,1])),1]
# Let's examine what this does
print(head(light.dir))
# Wrapper function which runs TLUtilies::vertical_profiles(), trawllight::filter_stepwise(), and trawllight::calculate_attenuation() for every cast in each of the target directories. It is advisable to process only a few dierectories at a time due R memory limits and the potential for processing errors to occur. "Downcast" and "Upcast" should be processed separately. Here, I only use the 10th directory for Vessel 89, Cruise 200801
ebs <- process_all(dir.structure = light.dir[10:12],
cast.dir = "Downcast",
silent = T)
# Let's examine what this does
print(head(light.dir))
dir(light.dir[1])
dir()
light.dir[1]
getwd()
dir("../testing_space")
setwd("../testing_space")
# Wrapper function which runs TLUtilies::vertical_profiles(), trawllight::filter_stepwise(), and trawllight::calculate_attenuation() for every cast in each of the target directories. It is advisable to process only a few dierectories at a time due R memory limits and the potential for processing errors to occur. "Downcast" and "Upcast" should be processed separately. Here, I only use the 10th directory for Vessel 89, Cruise 200801
ebs <- process_all(dir.structure = light.dir[10:12],
cast.dir = "Downcast",
silent = T)
### Demonstrating alternative algorithms to smooth raw light data
require(trawllight)
require(castr)
require(devtools)
test <- test_process_all(dir.structure = "../../../Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_09/ebs/v_89",
cast.dir = "Downcast",
silent = T)
test
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
rm(test)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
cast_wrapper <- function(x, id.col, FUN, min.rows = 4, ...) {
# Create a unique ID column over which to loop
x$id.col <- eval(parse(text = paste0("paste(", paste(paste0("x$", id.col), collapse = ","),")")))
unique_ids <- unique(x$id.col)
output.df <- NULL
rowind <- 0
for(i in 1:length(unique_ids)) {
# Apply function to cast
EEE <- subset(x, id.col == unique_ids[i])
if(nrow(EEE) > min.rows) {
EEE.out <- do.call(FUN, args = list(x = EEE, ...))
if(is.null(output.df)) {
output.df <- EEE.out
rowind <- nrow(output.df)+1
output.df[rowind:(nrow(output.df)+(nrow(x)*1.2)),] <- NA
} else {
print(rowind:(rowind + nrow(EEE.out)))
output.df[rowind:(rowind + nrow(EEE.out)-1),] <- EEE.out[1:nrow(EEE.out),]
rowind <- rowind + nrow(EEE.out)+1
#output.df <- plyr::rbind.fill(output.df, EEE.out)
print(nrow(EEE.out)-nrow(EEE))
}
if(i %% 1000 == 0) {
print(i)
print(rowind)
}
}
}
output.df <- output.df[,-which(names(output.df) == "id.col")]
return(output.df)
}
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
library(TLUtilities)
rm(list = ls())
library(TLUtilities)
library(TLUtilities)
